import type { GeneratedType } from "@cosmjs/proto-signing";
import type { Auditor as Auditor_type, MsgApplyPendingBalanceResponse as MsgApplyPendingBalanceResponse_type, MsgApplyPendingBalance as MsgApplyPendingBalance_type, MsgCloseAccountResponse as MsgCloseAccountResponse_type, MsgCloseAccount as MsgCloseAccount_type, MsgDepositResponse as MsgDepositResponse_type, MsgDeposit as MsgDeposit_type, MsgInitializeAccountResponse as MsgInitializeAccountResponse_type, MsgInitializeAccount as MsgInitializeAccount_type, MsgTransferResponse as MsgTransferResponse_type, MsgTransfer as MsgTransfer_type, MsgWithdrawResponse as MsgWithdrawResponse_type, MsgWithdraw as MsgWithdraw_type } from "../../types/confidentialtransfers";
import type { MessageFns } from "../common";
export interface MsgTransfer extends MsgTransfer_type {
}
export interface MsgTransferResponse extends MsgTransferResponse_type {
}
export interface Auditor extends Auditor_type {
}
export interface MsgInitializeAccount extends MsgInitializeAccount_type {
}
export interface MsgInitializeAccountResponse extends MsgInitializeAccountResponse_type {
}
export interface MsgDeposit extends MsgDeposit_type {
}
export interface MsgDepositResponse extends MsgDepositResponse_type {
}
export interface MsgWithdraw extends MsgWithdraw_type {
}
export interface MsgWithdrawResponse extends MsgWithdrawResponse_type {
}
export interface MsgApplyPendingBalance extends MsgApplyPendingBalance_type {
}
export interface MsgApplyPendingBalanceResponse extends MsgApplyPendingBalanceResponse_type {
}
export interface MsgCloseAccount extends MsgCloseAccount_type {
}
export interface MsgCloseAccountResponse extends MsgCloseAccountResponse_type {
}
export declare const MsgTransfer: MessageFns<MsgTransfer, "seiprotocol.seichain.confidentialtransfers.MsgTransfer">;
export declare const MsgTransferResponse: MessageFns<MsgTransferResponse, "seiprotocol.seichain.confidentialtransfers.MsgTransferResponse">;
export declare const Auditor: MessageFns<Auditor, "seiprotocol.seichain.confidentialtransfers.Auditor">;
export declare const MsgInitializeAccount: MessageFns<MsgInitializeAccount, "seiprotocol.seichain.confidentialtransfers.MsgInitializeAccount">;
export declare const MsgInitializeAccountResponse: MessageFns<MsgInitializeAccountResponse, "seiprotocol.seichain.confidentialtransfers.MsgInitializeAccountResponse">;
export declare const MsgDeposit: MessageFns<MsgDeposit, "seiprotocol.seichain.confidentialtransfers.MsgDeposit">;
export declare const MsgDepositResponse: MessageFns<MsgDepositResponse, "seiprotocol.seichain.confidentialtransfers.MsgDepositResponse">;
export declare const MsgWithdraw: MessageFns<MsgWithdraw, "seiprotocol.seichain.confidentialtransfers.MsgWithdraw">;
export declare const MsgWithdrawResponse: MessageFns<MsgWithdrawResponse, "seiprotocol.seichain.confidentialtransfers.MsgWithdrawResponse">;
export declare const MsgApplyPendingBalance: MessageFns<MsgApplyPendingBalance, "seiprotocol.seichain.confidentialtransfers.MsgApplyPendingBalance">;
export declare const MsgApplyPendingBalanceResponse: MessageFns<MsgApplyPendingBalanceResponse, "seiprotocol.seichain.confidentialtransfers.MsgApplyPendingBalanceResponse">;
export declare const MsgCloseAccount: MessageFns<MsgCloseAccount, "seiprotocol.seichain.confidentialtransfers.MsgCloseAccount">;
export declare const MsgCloseAccountResponse: MessageFns<MsgCloseAccountResponse, "seiprotocol.seichain.confidentialtransfers.MsgCloseAccountResponse">;
export declare const registry: Array<[string, GeneratedType]>;
export declare const aminoConverters: {
    "/seiprotocol.seichain.confidentialtransfers.MsgTransfer": {
        aminoType: string;
        toAmino: (message: MsgTransfer) => {
            from_address: string;
            to_address: string;
            denom: string;
            from_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            from_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            to_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            to_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            remaining_balance?: import("../../types/confidentialtransfers").Ciphertext;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").TransferMsgProofs;
            auditors: Auditor_type[];
        };
        fromAmino: (object: MsgTransfer) => {
            from_address: string;
            to_address: string;
            denom: string;
            from_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            from_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            to_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            to_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            remaining_balance?: import("../../types/confidentialtransfers").Ciphertext;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").TransferMsgProofs;
            auditors: Auditor_type[];
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgTransferResponse": {
        aminoType: string;
        toAmino: (message: MsgTransferResponse) => {};
        fromAmino: (object: MsgTransferResponse) => {};
    };
    "/seiprotocol.seichain.confidentialtransfers.Auditor": {
        aminoType: string;
        toAmino: (message: Auditor) => {
            auditor_address: string;
            encrypted_transfer_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            encrypted_transfer_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            transfer_amount_lo_validity_proof?: import("../../types/confidentialtransfers").CiphertextValidityProof;
            transfer_amount_hi_validity_proof?: import("../../types/confidentialtransfers").CiphertextValidityProof;
            transfer_amount_lo_equality_proof?: import("../../types/confidentialtransfers").CiphertextCiphertextEqualityProof;
            transfer_amount_hi_equality_proof?: import("../../types/confidentialtransfers").CiphertextCiphertextEqualityProof;
        };
        fromAmino: (object: Auditor) => {
            auditor_address: string;
            encrypted_transfer_amount_lo?: import("../../types/confidentialtransfers").Ciphertext;
            encrypted_transfer_amount_hi?: import("../../types/confidentialtransfers").Ciphertext;
            transfer_amount_lo_validity_proof?: import("../../types/confidentialtransfers").CiphertextValidityProof;
            transfer_amount_hi_validity_proof?: import("../../types/confidentialtransfers").CiphertextValidityProof;
            transfer_amount_lo_equality_proof?: import("../../types/confidentialtransfers").CiphertextCiphertextEqualityProof;
            transfer_amount_hi_equality_proof?: import("../../types/confidentialtransfers").CiphertextCiphertextEqualityProof;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgInitializeAccount": {
        aminoType: string;
        toAmino: (message: MsgInitializeAccount) => {
            from_address: string;
            denom: string;
            public_key: Uint8Array;
            decryptable_balance: string;
            pending_balance_lo?: import("../../types/confidentialtransfers").Ciphertext;
            pending_balance_hi?: import("../../types/confidentialtransfers").Ciphertext;
            available_balance?: import("../../types/confidentialtransfers").Ciphertext;
            proofs?: import("../../types/confidentialtransfers").InitializeAccountMsgProofs;
        };
        fromAmino: (object: MsgInitializeAccount) => {
            from_address: string;
            denom: string;
            public_key: Uint8Array;
            decryptable_balance: string;
            pending_balance_lo?: import("../../types/confidentialtransfers").Ciphertext;
            pending_balance_hi?: import("../../types/confidentialtransfers").Ciphertext;
            available_balance?: import("../../types/confidentialtransfers").Ciphertext;
            proofs?: import("../../types/confidentialtransfers").InitializeAccountMsgProofs;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgInitializeAccountResponse": {
        aminoType: string;
        toAmino: (message: MsgInitializeAccountResponse) => {};
        fromAmino: (object: MsgInitializeAccountResponse) => {};
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgDeposit": {
        aminoType: string;
        toAmino: (message: MsgDeposit) => {
            from_address: string;
            denom: string;
            amount: number;
        };
        fromAmino: (object: MsgDeposit) => {
            from_address: string;
            denom: string;
            amount: number;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgDepositResponse": {
        aminoType: string;
        toAmino: (message: MsgDepositResponse) => {};
        fromAmino: (object: MsgDepositResponse) => {};
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgWithdraw": {
        aminoType: string;
        toAmino: (message: MsgWithdraw) => {
            from_address: string;
            denom: string;
            amount: string;
            decryptable_balance: string;
            remaining_balance_commitment?: import("../../types/confidentialtransfers").Ciphertext;
            proofs?: import("../../types/confidentialtransfers").WithdrawMsgProofs;
        };
        fromAmino: (object: MsgWithdraw) => {
            from_address: string;
            denom: string;
            amount: string;
            decryptable_balance: string;
            remaining_balance_commitment?: import("../../types/confidentialtransfers").Ciphertext;
            proofs?: import("../../types/confidentialtransfers").WithdrawMsgProofs;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgWithdrawResponse": {
        aminoType: string;
        toAmino: (message: MsgWithdrawResponse) => {};
        fromAmino: (object: MsgWithdrawResponse) => {};
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgApplyPendingBalance": {
        aminoType: string;
        toAmino: (message: MsgApplyPendingBalance) => {
            address: string;
            denom: string;
            new_decryptable_available_balance: string;
            current_pending_balance_counter: number;
            current_available_balance?: import("../../types/confidentialtransfers").Ciphertext;
        };
        fromAmino: (object: MsgApplyPendingBalance) => {
            address: string;
            denom: string;
            new_decryptable_available_balance: string;
            current_pending_balance_counter: number;
            current_available_balance?: import("../../types/confidentialtransfers").Ciphertext;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgApplyPendingBalanceResponse": {
        aminoType: string;
        toAmino: (message: MsgApplyPendingBalanceResponse) => {};
        fromAmino: (object: MsgApplyPendingBalanceResponse) => {};
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgCloseAccount": {
        aminoType: string;
        toAmino: (message: MsgCloseAccount) => {
            address: string;
            denom: string;
            proofs?: import("../../types/confidentialtransfers").CloseAccountMsgProofs;
        };
        fromAmino: (object: MsgCloseAccount) => {
            address: string;
            denom: string;
            proofs?: import("../../types/confidentialtransfers").CloseAccountMsgProofs;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.MsgCloseAccountResponse": {
        aminoType: string;
        toAmino: (message: MsgCloseAccountResponse) => {};
        fromAmino: (object: MsgCloseAccountResponse) => {};
    };
};
