import type { GeneratedType } from "@cosmjs/proto-signing";
import type { ApplyPendingBalanceDecrypted as ApplyPendingBalanceDecrypted_type, DecryptedCtAccount as DecryptedCtAccount_type, GetAllCtAccountsRequest as GetAllCtAccountsRequest_type, GetAllCtAccountsResponse as GetAllCtAccountsResponse_type, GetCtAccountRequest as GetCtAccountRequest_type, GetCtAccountResponse as GetCtAccountResponse_type, InitializeAccountDecrypted as InitializeAccountDecrypted_type, TransferDecrypted as TransferDecrypted_type, WithdrawDecrypted as WithdrawDecrypted_type } from "../../types/confidentialtransfers";
import type { MessageFns } from "../common";
export interface GetCtAccountRequest extends GetCtAccountRequest_type {
}
export interface GetCtAccountResponse extends GetCtAccountResponse_type {
}
export interface GetAllCtAccountsRequest extends GetAllCtAccountsRequest_type {
}
export interface GetAllCtAccountsResponse extends GetAllCtAccountsResponse_type {
}
export interface DecryptedCtAccount extends DecryptedCtAccount_type {
}
export interface ApplyPendingBalanceDecrypted extends ApplyPendingBalanceDecrypted_type {
}
export interface InitializeAccountDecrypted extends InitializeAccountDecrypted_type {
}
export interface WithdrawDecrypted extends WithdrawDecrypted_type {
}
export interface TransferDecrypted extends TransferDecrypted_type {
}
export declare const GetCtAccountRequest: MessageFns<GetCtAccountRequest, "seiprotocol.seichain.confidentialtransfers.GetCtAccountRequest">;
export declare const GetCtAccountResponse: MessageFns<GetCtAccountResponse, "seiprotocol.seichain.confidentialtransfers.GetCtAccountResponse">;
export declare const GetAllCtAccountsRequest: MessageFns<GetAllCtAccountsRequest, "seiprotocol.seichain.confidentialtransfers.GetAllCtAccountsRequest">;
export declare const GetAllCtAccountsResponse: MessageFns<GetAllCtAccountsResponse, "seiprotocol.seichain.confidentialtransfers.GetAllCtAccountsResponse">;
export declare const DecryptedCtAccount: MessageFns<DecryptedCtAccount, "seiprotocol.seichain.confidentialtransfers.DecryptedCtAccount">;
export declare const ApplyPendingBalanceDecrypted: MessageFns<ApplyPendingBalanceDecrypted, "seiprotocol.seichain.confidentialtransfers.ApplyPendingBalanceDecrypted">;
export declare const InitializeAccountDecrypted: MessageFns<InitializeAccountDecrypted, "seiprotocol.seichain.confidentialtransfers.InitializeAccountDecrypted">;
export declare const WithdrawDecrypted: MessageFns<WithdrawDecrypted, "seiprotocol.seichain.confidentialtransfers.WithdrawDecrypted">;
export declare const TransferDecrypted: MessageFns<TransferDecrypted, "seiprotocol.seichain.confidentialtransfers.TransferDecrypted">;
export declare const registry: Array<[string, GeneratedType]>;
export declare const aminoConverters: {
    "/seiprotocol.seichain.confidentialtransfers.GetCtAccountRequest": {
        aminoType: string;
        toAmino: (message: GetCtAccountRequest) => {
            address: string;
            denom: string;
        };
        fromAmino: (object: GetCtAccountRequest) => {
            address: string;
            denom: string;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.GetCtAccountResponse": {
        aminoType: string;
        toAmino: (message: GetCtAccountResponse) => {
            account?: import("../../types/confidentialtransfers").CtAccount;
        };
        fromAmino: (object: GetCtAccountResponse) => {
            account?: import("../../types/confidentialtransfers").CtAccount;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.GetAllCtAccountsRequest": {
        aminoType: string;
        toAmino: (message: GetAllCtAccountsRequest) => {
            address: string;
            pagination?: import("../../types/cosmos/base/query/v1beta1").PageRequest;
        };
        fromAmino: (object: GetAllCtAccountsRequest) => {
            address: string;
            pagination?: import("../../types/cosmos/base/query/v1beta1").PageRequest;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.GetAllCtAccountsResponse": {
        aminoType: string;
        toAmino: (message: GetAllCtAccountsResponse) => {
            accounts: import("../../types/confidentialtransfers").CtAccountWithDenom[];
            pagination?: import("../../types/cosmos/base/query/v1beta1").PageResponse;
        };
        fromAmino: (object: GetAllCtAccountsResponse) => {
            accounts: import("../../types/confidentialtransfers").CtAccountWithDenom[];
            pagination?: import("../../types/cosmos/base/query/v1beta1").PageResponse;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.DecryptedCtAccount": {
        aminoType: string;
        toAmino: (message: DecryptedCtAccount) => {
            public_key: Uint8Array;
            pending_balance_lo: number;
            pending_balance_hi: number;
            combined_pending_balance: string;
            pending_balance_credit_counter: number;
            available_balance: string;
            decryptable_available_balance: string;
        };
        fromAmino: (object: DecryptedCtAccount) => {
            public_key: Uint8Array;
            pending_balance_lo: number;
            pending_balance_hi: number;
            combined_pending_balance: string;
            pending_balance_credit_counter: number;
            available_balance: string;
            decryptable_available_balance: string;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.ApplyPendingBalanceDecrypted": {
        aminoType: string;
        toAmino: (message: ApplyPendingBalanceDecrypted) => {
            address: string;
            denom: string;
            new_decryptable_available_balance: string;
            current_pending_balance_counter: number;
            current_available_balance: string;
        };
        fromAmino: (object: ApplyPendingBalanceDecrypted) => {
            address: string;
            denom: string;
            new_decryptable_available_balance: string;
            current_pending_balance_counter: number;
            current_available_balance: string;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.InitializeAccountDecrypted": {
        aminoType: string;
        toAmino: (message: InitializeAccountDecrypted) => {
            from_address: string;
            denom: string;
            pubkey: Uint8Array;
            pending_balance_lo: number;
            pending_balance_hi: number;
            available_balance: string;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").InitializeAccountMsgProofs;
        };
        fromAmino: (object: InitializeAccountDecrypted) => {
            from_address: string;
            denom: string;
            pubkey: Uint8Array;
            pending_balance_lo: number;
            pending_balance_hi: number;
            available_balance: string;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").InitializeAccountMsgProofs;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.WithdrawDecrypted": {
        aminoType: string;
        toAmino: (message: WithdrawDecrypted) => {
            from_address: string;
            denom: string;
            amount: string;
            decryptable_balance: string;
            remaining_balance_commitment: string;
            proofs?: import("../../types/confidentialtransfers").WithdrawMsgProofs;
        };
        fromAmino: (object: WithdrawDecrypted) => {
            from_address: string;
            denom: string;
            amount: string;
            decryptable_balance: string;
            remaining_balance_commitment: string;
            proofs?: import("../../types/confidentialtransfers").WithdrawMsgProofs;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.TransferDecrypted": {
        aminoType: string;
        toAmino: (message: TransferDecrypted) => {
            from_address: string;
            to_address: string;
            denom: string;
            transfer_amount_lo: number;
            transfer_amount_hi: number;
            total_transfer_amount: number;
            remaining_balance_commitment: string;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").TransferMsgProofs;
            auditors: string[];
        };
        fromAmino: (object: TransferDecrypted) => {
            from_address: string;
            to_address: string;
            denom: string;
            transfer_amount_lo: number;
            transfer_amount_hi: number;
            total_transfer_amount: number;
            remaining_balance_commitment: string;
            decryptable_balance: string;
            proofs?: import("../../types/confidentialtransfers").TransferMsgProofs;
            auditors: string[];
        };
    };
};
