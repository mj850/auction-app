import type { GeneratedType } from "@cosmjs/proto-signing";
import type { CiphertextCiphertextEqualityProof as CiphertextCiphertextEqualityProof_type, CiphertextCommitmentEqualityProof as CiphertextCommitmentEqualityProof_type, CiphertextValidityProof as CiphertextValidityProof_type, CloseAccountMsgProofs as CloseAccountMsgProofs_type, InitializeAccountMsgProofs as InitializeAccountMsgProofs_type, PubkeyValidityProof as PubkeyValidityProof_type, RangeProof as RangeProof_type, TransferMsgProofs as TransferMsgProofs_type, WithdrawMsgProofs as WithdrawMsgProofs_type, ZeroBalanceProof as ZeroBalanceProof_type } from "../../types/confidentialtransfers";
import type { MessageFns } from "../common";
export interface TransferMsgProofs extends TransferMsgProofs_type {
}
export interface InitializeAccountMsgProofs extends InitializeAccountMsgProofs_type {
}
export interface WithdrawMsgProofs extends WithdrawMsgProofs_type {
}
export interface CloseAccountMsgProofs extends CloseAccountMsgProofs_type {
}
export interface PubkeyValidityProof extends PubkeyValidityProof_type {
}
export interface CiphertextValidityProof extends CiphertextValidityProof_type {
}
export interface RangeProof extends RangeProof_type {
}
export interface CiphertextCommitmentEqualityProof extends CiphertextCommitmentEqualityProof_type {
}
export interface CiphertextCiphertextEqualityProof extends CiphertextCiphertextEqualityProof_type {
}
export interface ZeroBalanceProof extends ZeroBalanceProof_type {
}
export declare const TransferMsgProofs: MessageFns<TransferMsgProofs, "seiprotocol.seichain.confidentialtransfers.TransferMsgProofs">;
export declare const InitializeAccountMsgProofs: MessageFns<InitializeAccountMsgProofs, "seiprotocol.seichain.confidentialtransfers.InitializeAccountMsgProofs">;
export declare const WithdrawMsgProofs: MessageFns<WithdrawMsgProofs, "seiprotocol.seichain.confidentialtransfers.WithdrawMsgProofs">;
export declare const CloseAccountMsgProofs: MessageFns<CloseAccountMsgProofs, "seiprotocol.seichain.confidentialtransfers.CloseAccountMsgProofs">;
export declare const PubkeyValidityProof: MessageFns<PubkeyValidityProof, "seiprotocol.seichain.confidentialtransfers.PubkeyValidityProof">;
export declare const CiphertextValidityProof: MessageFns<CiphertextValidityProof, "seiprotocol.seichain.confidentialtransfers.CiphertextValidityProof">;
export declare const RangeProof: MessageFns<RangeProof, "seiprotocol.seichain.confidentialtransfers.RangeProof">;
export declare const CiphertextCommitmentEqualityProof: MessageFns<CiphertextCommitmentEqualityProof, "seiprotocol.seichain.confidentialtransfers.CiphertextCommitmentEqualityProof">;
export declare const CiphertextCiphertextEqualityProof: MessageFns<CiphertextCiphertextEqualityProof, "seiprotocol.seichain.confidentialtransfers.CiphertextCiphertextEqualityProof">;
export declare const ZeroBalanceProof: MessageFns<ZeroBalanceProof, "seiprotocol.seichain.confidentialtransfers.ZeroBalanceProof">;
export declare const registry: Array<[string, GeneratedType]>;
export declare const aminoConverters: {
    "/seiprotocol.seichain.confidentialtransfers.TransferMsgProofs": {
        aminoType: string;
        toAmino: (message: TransferMsgProofs) => {
            remaining_balance_commitment_validity_proof?: CiphertextValidityProof_type;
            sender_transfer_amount_lo_validity_proof?: CiphertextValidityProof_type;
            sender_transfer_amount_hi_validity_proof?: CiphertextValidityProof_type;
            recipient_transfer_amount_lo_validity_proof?: CiphertextValidityProof_type;
            recipient_transfer_amount_hi_validity_proof?: CiphertextValidityProof_type;
            remaining_balance_range_proof?: RangeProof_type;
            remaining_balance_equality_proof?: CiphertextCommitmentEqualityProof_type;
            transfer_amount_lo_equality_proof?: CiphertextCiphertextEqualityProof_type;
            transfer_amount_hi_equality_proof?: CiphertextCiphertextEqualityProof_type;
            transfer_amount_lo_range_proof?: RangeProof_type;
            transfer_amount_hi_range_proof?: RangeProof_type;
        };
        fromAmino: (object: TransferMsgProofs) => {
            remaining_balance_commitment_validity_proof?: CiphertextValidityProof_type;
            sender_transfer_amount_lo_validity_proof?: CiphertextValidityProof_type;
            sender_transfer_amount_hi_validity_proof?: CiphertextValidityProof_type;
            recipient_transfer_amount_lo_validity_proof?: CiphertextValidityProof_type;
            recipient_transfer_amount_hi_validity_proof?: CiphertextValidityProof_type;
            remaining_balance_range_proof?: RangeProof_type;
            remaining_balance_equality_proof?: CiphertextCommitmentEqualityProof_type;
            transfer_amount_lo_equality_proof?: CiphertextCiphertextEqualityProof_type;
            transfer_amount_hi_equality_proof?: CiphertextCiphertextEqualityProof_type;
            transfer_amount_lo_range_proof?: RangeProof_type;
            transfer_amount_hi_range_proof?: RangeProof_type;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.InitializeAccountMsgProofs": {
        aminoType: string;
        toAmino: (message: InitializeAccountMsgProofs) => {
            pubkey_validity_proof?: PubkeyValidityProof_type;
            zero_pending_balance_lo_proof?: ZeroBalanceProof_type;
            zero_pending_balance_hi_proof?: ZeroBalanceProof_type;
            zero_available_balance_proof?: ZeroBalanceProof_type;
        };
        fromAmino: (object: InitializeAccountMsgProofs) => {
            pubkey_validity_proof?: PubkeyValidityProof_type;
            zero_pending_balance_lo_proof?: ZeroBalanceProof_type;
            zero_pending_balance_hi_proof?: ZeroBalanceProof_type;
            zero_available_balance_proof?: ZeroBalanceProof_type;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.WithdrawMsgProofs": {
        aminoType: string;
        toAmino: (message: WithdrawMsgProofs) => {
            remaining_balance_range_proof?: RangeProof_type;
            remaining_balance_equality_proof?: CiphertextCommitmentEqualityProof_type;
        };
        fromAmino: (object: WithdrawMsgProofs) => {
            remaining_balance_range_proof?: RangeProof_type;
            remaining_balance_equality_proof?: CiphertextCommitmentEqualityProof_type;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.CloseAccountMsgProofs": {
        aminoType: string;
        toAmino: (message: CloseAccountMsgProofs) => {
            zero_available_balance_proof?: ZeroBalanceProof_type;
            zero_pending_balance_lo_proof?: ZeroBalanceProof_type;
            zero_pending_balance_hi_proof?: ZeroBalanceProof_type;
        };
        fromAmino: (object: CloseAccountMsgProofs) => {
            zero_available_balance_proof?: ZeroBalanceProof_type;
            zero_pending_balance_lo_proof?: ZeroBalanceProof_type;
            zero_pending_balance_hi_proof?: ZeroBalanceProof_type;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.PubkeyValidityProof": {
        aminoType: string;
        toAmino: (message: PubkeyValidityProof) => {
            y: Uint8Array;
            z: Uint8Array;
        };
        fromAmino: (object: PubkeyValidityProof) => {
            y: Uint8Array;
            z: Uint8Array;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.CiphertextValidityProof": {
        aminoType: string;
        toAmino: (message: CiphertextValidityProof) => {
            commitment_1: Uint8Array;
            commitment_2: Uint8Array;
            response_1: Uint8Array;
            response_2: Uint8Array;
        };
        fromAmino: (object: CiphertextValidityProof) => {
            commitment_1: Uint8Array;
            commitment_2: Uint8Array;
            response_1: Uint8Array;
            response_2: Uint8Array;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.RangeProof": {
        aminoType: string;
        toAmino: (message: RangeProof) => {
            proof: Uint8Array;
            randomness: Uint8Array;
            upper_bound: number;
        };
        fromAmino: (object: RangeProof) => {
            proof: Uint8Array;
            randomness: Uint8Array;
            upper_bound: number;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.CiphertextCommitmentEqualityProof": {
        aminoType: string;
        toAmino: (message: CiphertextCommitmentEqualityProof) => {
            y0: Uint8Array;
            y1: Uint8Array;
            y2: Uint8Array;
            zs: Uint8Array;
            zx: Uint8Array;
            zr: Uint8Array;
        };
        fromAmino: (object: CiphertextCommitmentEqualityProof) => {
            y0: Uint8Array;
            y1: Uint8Array;
            y2: Uint8Array;
            zs: Uint8Array;
            zx: Uint8Array;
            zr: Uint8Array;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.CiphertextCiphertextEqualityProof": {
        aminoType: string;
        toAmino: (message: CiphertextCiphertextEqualityProof) => {
            y0: Uint8Array;
            y1: Uint8Array;
            y2: Uint8Array;
            y3: Uint8Array;
            zs: Uint8Array;
            zx: Uint8Array;
            zr: Uint8Array;
        };
        fromAmino: (object: CiphertextCiphertextEqualityProof) => {
            y0: Uint8Array;
            y1: Uint8Array;
            y2: Uint8Array;
            y3: Uint8Array;
            zs: Uint8Array;
            zx: Uint8Array;
            zr: Uint8Array;
        };
    };
    "/seiprotocol.seichain.confidentialtransfers.ZeroBalanceProof": {
        aminoType: string;
        toAmino: (message: ZeroBalanceProof) => {
            y_p: Uint8Array;
            y_d: Uint8Array;
            z: Uint8Array;
        };
        fromAmino: (object: ZeroBalanceProof) => {
            y_p: Uint8Array;
            y_d: Uint8Array;
            z: Uint8Array;
        };
    };
};
