"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryAccountViem = queryAccountViem;
exports.decryptPendingBalancesViem = decryptPendingBalancesViem;
exports.decryptDecryptableAvailableBalanceViem = decryptDecryptableAvailableBalanceViem;
exports.decryptAvailableBalanceViem = decryptAvailableBalanceViem;
exports.decryptAccountViem = decryptAccountViem;
exports.getInitializeAccountViemArgs = getInitializeAccountViemArgs;
exports.getDepositToPrivateBalanceViemArgs = getDepositToPrivateBalanceViemArgs;
exports.getApplyPendingBalancesViemArgs = getApplyPendingBalancesViemArgs;
exports.getWithdrawFromPrivateBalanceViemArgs = getWithdrawFromPrivateBalanceViemArgs;
exports.getConfidentialTransferViemArgs = getConfidentialTransferViemArgs;
exports.getDenomToSignViem = getDenomToSignViem;
const encoding_1 = require("@sei-js/cosmos/encoding");
const evm_1 = require("@sei-js/evm");
const viem_1 = require("viem");
const confidentialApi_1 = require("../payload/confidentialApi");
/**
 * Queries the on-chain confidential account state for a given address and denom.
 *
 * @param client - A Viem PublicClient instance.
 * @param address - The 0x account address to query.
 * @param denom - The denom of the confidential account.
 * @returns A CtAccountResponse object, or null if the account is not initialized.
 */
async function queryAccountViem(client, address, denom) {
    // Sanity checks
    if (!(0, viem_1.isAddress)(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    let account;
    try {
        account = await client.readContract({
            abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
            address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
            functionName: "account",
            args: [address, denom]
        });
        return account;
    }
    catch (error) {
        console.error("Error fetching account:", error.message);
        return null;
    }
}
/**
 * Decrypts the pending balance ciphertexts from a CtAccount.
 *
 * @param signedDenom - Signature over the hashed denom generated by getDenomToSignViem.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The low, high, and combined pending balances.
 */
async function decryptPendingBalancesViem(signedDenom, ctAccount) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const pendingBalanceLo = api.decryptCiphertext(signedDenomArray, (0, viem_1.hexToBytes)(ctAccount.pendingBalanceLo));
    const pendingBalanceHi = api.decryptCiphertext(signedDenomArray, (0, viem_1.hexToBytes)(ctAccount.pendingBalanceHi));
    return {
        pendingBalanceLo: pendingBalanceLo,
        pendingBalanceHi: pendingBalanceHi,
        totalPendingBalance: pendingBalanceLo + (pendingBalanceHi << BigInt(16))
    };
}
/**
 * Decrypts the AES-encrypted decryptable available balance.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The decrypted available balance.
 */
async function decryptDecryptableAvailableBalanceViem(signedDenom, ctAccount) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const decryptableAvailableBalance = api.decryptAesCiphertext(signedDenomArray, ctAccount.decryptableAvailableBalance);
    return decryptableAvailableBalance;
}
/**
 * Fully decrypts the committed available balance (slow path).
 * Only needed if decryptable balance is insufficient or untrusted.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @returns The decrypted available balance.
 */
async function decryptAvailableBalanceViem(signedDenom, ctAccount) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const availableBalance = api.decryptCiphertext(signedDenomArray, (0, viem_1.hexToBytes)(ctAccount.availableBalance));
    return availableBalance;
}
/**
 * Fully decrypts all encrypted components of a confidential account.
 *
 * @param signedDenom - The signed hash of the denom.
 * @param ctAccount - The confidential account to decrypt.
 * @param decryptFullAvailableBalance - Whether to decrypt the available balance (slow).
 * @returns A DecryptedAccount object.
 */
async function decryptAccountViem(signedDenom, ctAccount, decryptFullAvailableBalance) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const decryptedPendingBalances = await decryptPendingBalancesViem(signedDenom, ctAccount);
    const decryptedDecryptableAvailableBalance = await decryptDecryptableAvailableBalanceViem(signedDenom, ctAccount);
    const data = {
        publicKey: ctAccount.publicKey,
        pendingBalanceLo: decryptedPendingBalances.pendingBalanceLo,
        pendingBalanceHi: decryptedPendingBalances.pendingBalanceHi,
        totalPendingBalance: decryptedPendingBalances.totalPendingBalance,
        pendingBalanceCreditCounter: ctAccount.pendingBalanceCreditCounter,
        availableBalance: "Not Decrypted",
        decryptableAvailableBalance: decryptedDecryptableAvailableBalance
    };
    if (decryptFullAvailableBalance) {
        const decryptedAvailableBalance = await decryptAvailableBalanceViem(signedDenom, ctAccount);
        data.availableBalance = decryptedAvailableBalance.toString();
    }
    return data;
}
/**
 * Generates calldata for depositing into a confidential account.
 *
 * @param address - The address initiating the deposit.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to deposit.
 * @returns A Viem-compatible calldata params object.
 */
async function getInitializeAccountViemArgs(signedDenom, address, denom) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!(0, viem_1.isAddress)(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const initializePayload = api.createInitialize(signedDenomArray, address, denom);
    let encodedPendingBalanceLo = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.pending_balance_lo).finish();
    let encodedPendingBalanceHi = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.pending_balance_hi).finish();
    let encodedAvailableBalance = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(initializePayload.available_balance).finish();
    const encodedProofs = encoding_1.Encoder.confidentialtransfers.InitializeAccountMsgProofs.encode(initializePayload.proofs).finish();
    const encodedPendingBalanceLoHex = (0, viem_1.bytesToHex)(encodedPendingBalanceLo);
    const encodedPendingBalanceHiHex = (0, viem_1.bytesToHex)(encodedPendingBalanceHi);
    const encodedAvailableBalanceHex = (0, viem_1.bytesToHex)(encodedAvailableBalance);
    const publicKeyHex = (0, viem_1.bytesToHex)(initializePayload.public_key);
    const encodedProofsHex = (0, viem_1.bytesToHex)(encodedProofs);
    const params = {
        account: initializePayload.from_address,
        address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "initializeAccount",
        args: [
            initializePayload.from_address,
            initializePayload.denom,
            publicKeyHex,
            initializePayload.decryptable_balance,
            encodedPendingBalanceLoHex,
            encodedPendingBalanceHiHex,
            encodedAvailableBalanceHex,
            encodedProofsHex
        ],
        value: (0, viem_1.parseEther)('0')
    };
    return params;
}
/**
 * Generates calldata for depositing into a confidential account.
 *
 * @param address - The 0x address initiating the deposit.
 * @param denom - The denom of the confidential account.
 * @param amount - Amount to deposit in base units (e.g., 1 SEI = 1_000_000).
 * @returns A Viem-compatible calldata params object.
 */
function getDepositToPrivateBalanceViemArgs(address, denom, amount) {
    // Sanity checks
    if (address && !(0, viem_1.isAddress)(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= BigInt(0)) {
        throw new Error('Amount must be a positive number');
    }
    const params = {
        account: address,
        address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "deposit",
        args: [denom, amount]
    };
    return params;
}
/**
 * Generates calldata for applying pending balances to a confidential account.
 *
 * @param address - The 0x address of the account.
 * @param denom - The denom of the confidential account.
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if the account is uninitialized.
 */
async function getApplyPendingBalancesViemArgs(address, denom, client, signedDenom) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!(0, viem_1.isAddress)(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const ctAccount = await queryAccountViem(client, address, denom);
    if (ctAccount === null) {
        return null;
    }
    const applyPendingBalancesPayload = api.createApplyPendingBalance(signedDenomArray, address, denom, ctAccount.pendingBalanceCreditCounter, ctAccount.decryptableAvailableBalance, (0, viem_1.hexToBytes)(ctAccount.availableBalance), (0, viem_1.hexToBytes)(ctAccount.pendingBalanceLo), (0, viem_1.hexToBytes)(ctAccount.pendingBalanceHi));
    return getApplyPendingBalancesArgs(applyPendingBalancesPayload);
}
function getApplyPendingBalancesArgs(applyPayload) {
    let encodedAvailableBalance = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(applyPayload.current_available_balance).finish();
    const encodedAvailableBalanceHex = (0, viem_1.bytesToHex)(encodedAvailableBalance);
    const params = {
        account: applyPayload.address,
        address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "applyPendingBalance",
        args: [
            applyPayload.denom,
            applyPayload.new_decryptable_available_balance,
            applyPayload.current_pending_balance_counter,
            encodedAvailableBalanceHex,
        ],
        value: (0, viem_1.parseEther)('0')
    };
    return params;
}
/**
 * Generates calldata for withdrawing from a confidential account.
 *
 * @param address - The address of the account.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to withdraw in base units (e.g., 1 SEI = 1_000_000).
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if the account is uninitialized.
 */
async function getWithdrawFromPrivateBalanceViemArgs(address, denom, amount, client, signedDenom) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!(0, viem_1.isAddress)(address)) {
        throw new Error('Invalid address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= 0) {
        throw new Error('Amount must be a positive number');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const ctAccount = await queryAccountViem(client, address, denom);
    if (ctAccount === null) {
        return null;
    }
    const withdrawPayload = api.createWithdraw(signedDenomArray, amount, address, denom, ctAccount.decryptableAvailableBalance, (0, viem_1.hexToBytes)(ctAccount.availableBalance));
    return getWithdrawArgs(withdrawPayload);
}
function getWithdrawArgs(withdrawPayload) {
    let encodedRemainingBalanceCommitment = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(withdrawPayload.remaining_balance_commitment).finish();
    let encodedProofs = encoding_1.Encoder.confidentialtransfers.WithdrawMsgProofs.encode(withdrawPayload.proofs).finish();
    const encodedRemainingBalanceCommitmentHex = (0, viem_1.bytesToHex)(encodedRemainingBalanceCommitment);
    const encodedProofsHex = (0, viem_1.bytesToHex)(encodedProofs);
    const params = {
        account: withdrawPayload.from_address,
        address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "withdraw",
        args: [
            withdrawPayload.denom,
            withdrawPayload.amount,
            withdrawPayload.decryptable_balance,
            encodedRemainingBalanceCommitmentHex,
            encodedProofsHex,
        ],
        value: (0, viem_1.parseEther)('0')
    };
    return params;
}
/**
 * Generates calldata for transferring confidential balance to another account.
 *
 * @param senderAddress - The sender's address.
 * @param recipientAddress - The recipient's address.
 * @param denom - The denom of the confidential account.
 * @param amount - The amount to transfer.
 * @param client - A Viem PublicClient instance.
 * @param signedDenom - The signed hash of the denom.
 * @returns A Viem-compatible calldata params object or null if either account is uninitialized.
 */
async function getConfidentialTransferViemArgs(senderAddress, recipientAddress, denom, amount, client, signedDenom) {
    // Sanity checks
    if (!/^0x[0-9a-fA-F]+$/.test(signedDenom) || signedDenom.length !== 132) {
        throw new Error('Invalid signedDenom format');
    }
    if (!(0, viem_1.isAddress)(senderAddress)) {
        throw new Error('Invalid sender address format');
    }
    if (!(0, viem_1.isAddress)(recipientAddress)) {
        throw new Error('Invalid recipient address format');
    }
    if (denom.trim() === '') {
        throw new Error('Denom cannot be empty');
    }
    if (amount <= 0) {
        throw new Error('Amount must be a positive number');
    }
    const api = new confidentialApi_1.ConfidentialTransfersWrapper();
    await api.initialize();
    const signedDenomArray = (0, viem_1.hexToBytes)(signedDenom);
    const senderAccount = await queryAccountViem(client, senderAddress, denom);
    if (senderAccount === null) {
        return null;
    }
    const recipientAccount = await queryAccountViem(client, recipientAddress, denom);
    if (recipientAccount === null) {
        return null;
    }
    const transferPayload = api.createTransfer(signedDenomArray, amount, senderAddress, recipientAddress, denom, senderAccount.decryptableAvailableBalance, (0, viem_1.hexToBytes)(senderAccount.availableBalance), (0, viem_1.hexToBytes)(recipientAccount.publicKey));
    return getTransferArgs(transferPayload);
}
function getTransferArgs(transferPayload) {
    let encodedFromAmountLo = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.from_amount_lo).finish();
    let encodedFromAmountHi = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.from_amount_hi).finish();
    let encodedToAmountLo = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.to_amount_lo).finish();
    let encodedToAmountHi = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.to_amount_hi).finish();
    let encodedRemainingBalance = encoding_1.Encoder.confidentialtransfers.Ciphertext.encode(transferPayload.remaining_balance).finish();
    let encodedProofs = encoding_1.Encoder.confidentialtransfers.TransferMsgProofs.encode(transferPayload.proofs).finish();
    const encodedFromAmountLoHex = (0, viem_1.bytesToHex)(encodedFromAmountLo);
    const encodedFromAmountHiHex = (0, viem_1.bytesToHex)(encodedFromAmountHi);
    const encodedToAmountLoHex = (0, viem_1.bytesToHex)(encodedToAmountLo);
    const encodedToAmountHiHex = (0, viem_1.bytesToHex)(encodedToAmountHi);
    const encodedRemainingBalanceHex = (0, viem_1.bytesToHex)(encodedRemainingBalance);
    const encodedProofsHex = (0, viem_1.bytesToHex)(encodedProofs);
    const params = {
        account: transferPayload.from_address,
        address: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ADDRESS,
        abi: evm_1.CONFIDENTIAL_TRANSFERS_PRECOMPILE_ABI,
        functionName: "transfer",
        args: [
            transferPayload.to_address,
            transferPayload.denom,
            encodedFromAmountLoHex,
            encodedFromAmountHiHex,
            encodedToAmountLoHex,
            encodedToAmountHiHex,
            encodedRemainingBalanceHex,
            transferPayload.decryptable_balance,
            encodedProofsHex,
        ],
        value: (0, viem_1.parseEther)('0')
    };
    return params;
}
/**
 * Hashes a denom into the format expected by the signing process ("ct:" + denom).
 * Signing this hash generates a secret from which the confidential balances' private keypair can be derived.
 *
 * @param denom - The denom string (e.g., "usei").
 * @returns A keccak256 hash of the prefixed denom, ready to sign.
 */
function getDenomToSignViem(denom) {
    const appendedDenom = "ct:" + denom;
    const result = (0, viem_1.keccak256)((0, viem_1.toBytes)(appendedDenom));
    return result;
}
