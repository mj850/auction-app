"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethers_1 = require("ethers");
const testUtils_1 = require("./testUtils");
const confidentialTransfers_1 = require("../payload/confidentialTransfers");
const ethers_2 = require("../interface/ethers");
async function main() {
    // 1) Initialize an ethers provider (local chain at 8545)
    const provider = new ethers_1.ethers.JsonRpcProvider("http://localhost:8545");
    // 2) Create a signer - if you're using a local dev chain, 
    //    you can just use the first account it provides.
    //    Alternatively, you can load a private key or mnemonic.
    const testWallet = ethers_1.ethers.Wallet.createRandom().connect(provider);
    console.log(testWallet);
    // 3) Fund this new wallet from an admin/unlocked account at index 0
    await (0, testUtils_1.fundAddress)(testWallet.address);
    await delay(3000);
    const fundTx = await testWallet.sendTransaction({
        to: testWallet.address,
        value: ethers_1.ethers.parseEther("1.0"), // 1 ETH worth of funds, adjust as needed
    });
    await fundTx.wait();
    // 4) Get the user to sign the denom
    const denom = "usei";
    const denomHash = (0, ethers_2.getDenomToSignEthers)(denom);
    const signedDenom = await testWallet.signMessage(denomHash);
    console.log("Signed Denom:", signedDenom);
    /// INITIALIZE TEST
    // 5) Create the initialize object using the wasm library
    const api = new confidentialTransfers_1.ConfidentialTransfers();
    await api.initialize();
    // 5) Call the precompile with your chosen inputs
    console.log("Calling precompile...");
    await (0, ethers_2.initializeAccountEthers)(signedDenom, testWallet.address, denom, testWallet);
    // Now try to query the account on chain:
    let account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("Account on chain:", account);
    /// DEPOSIT TEST
    const depositAmount = 100000;
    await (0, ethers_2.depositToPrivateBalanceEthers)(denom, depositAmount, testWallet);
    account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("Account on chain:", account);
    /// APPLY PENDING BALANCE TEST
    let decryptedAccount = await (0, ethers_2.decryptAccountEthers)(signedDenom, account, false);
    console.log("Decrypted Before", decryptedAccount);
    await (0, ethers_2.applyPendingBalanceEthers)(testWallet.address, denom, signedDenom, testWallet);
    account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("Account on chain:", account);
    decryptedAccount = await (0, ethers_2.decryptAccountEthers)(signedDenom, account, false);
    console.log("Decrypted After", decryptedAccount);
    /// WITHDRAW TEST
    const withdrawAmount = 10000;
    await (0, ethers_2.withdrawFromPrivateBalanceEthers)(testWallet.address, denom, withdrawAmount, signedDenom, testWallet);
    account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("Account on chain:", account);
    // Transfer Test
    // Setup second wallet.
    // Create another signer 
    const otherWallet = ethers_1.ethers.Wallet.createRandom().connect(provider);
    console.log(otherWallet);
    // Fund this new wallet from an admin/unlocked account at index 0
    const fundOtherResult = await (0, testUtils_1.fundAddress)(otherWallet.address);
    await delay(3000);
    const fundOtherTx = await otherWallet.sendTransaction({
        to: otherWallet.address,
        value: ethers_1.ethers.parseEther("1.0"), // 1 ETH worth of funds, adjust as needed
    });
    await fundOtherTx.wait();
    // Sign the denom with the second wallet
    const othersignedDenom = await otherWallet.signMessage(denomHash);
    await (0, ethers_2.initializeAccountEthers)(othersignedDenom, otherWallet.address, denom, otherWallet);
    let otherAccount = await (0, ethers_2.queryAccountEthers)(otherWallet.address, denom, testWallet);
    if (otherAccount == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("OtherAccount on chain:", otherAccount);
    await (0, ethers_2.confidentialTransferEthers)(testWallet.address, otherWallet.address, denom, depositAmount - withdrawAmount, signedDenom, testWallet);
    otherAccount = await (0, ethers_2.queryAccountEthers)(otherWallet.address, denom, testWallet);
    if (otherAccount == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("OtherAccount on chain:", otherAccount);
    account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account == null) {
        console.log("TEST FAILED: Unexpected Error: Could not query account");
        return;
    }
    console.log("Account on chain:", account);
    // CloseAccount Test
    await (0, ethers_2.closeAccountEthers)(testWallet.address, denom, signedDenom, testWallet);
    account = await (0, ethers_2.queryAccountEthers)(testWallet.address, denom, testWallet);
    if (account != null) {
        console.log("Test Failed: Account should have been closed.");
        return;
    }
}
main().catch((err) => {
    console.error("Error:", err);
    process.exit(1);
});
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
